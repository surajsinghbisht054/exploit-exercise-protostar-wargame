#########################################################
                   Hint
#########################################################

This level introduces the Doug Lea Malloc (dlmalloc) and how heap meta data can be modified to change program execution.

This level is at /opt/protostar/bin/heap3


############################################################
                       Source Code
############################################################

#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <stdio.h>

void winner()
{
  printf("that wasn't too bad now, was it? @ %d\n", time(NULL));
}

int main(int argc, char **argv)
{
  char *a, *b, *c;

  a = malloc(32);
  b = malloc(32);
  c = malloc(32);

  strcpy(a, argv[1]);
  strcpy(b, argv[2]);
  strcpy(c, argv[3]);

  free(c);
  free(b);
  free(a);

  printf("dynamite failed?\n");
}









########################################################
						Plan
#########################################################

  a = malloc(32);
  b = malloc(32);
  c = malloc(32);
                      Location allocated One by one series wise.. Means, Previous one can overwrite current location.
					  
					  
					  
  
  strcpy(a, argv[1]);
  strcpy(b, argv[2]);
  strcpy(c, argv[3]);
                     Copying String Without any types of verification into space.
					 
  .
  free(c);
  free(b);
  free(a);          
                    Deallocating space one by one. 
					
					
	Here, we have to exploit.. Unlink algorithm, works under the free algorithm.
	
	Basically, Unlink algorithm merge to free deallocated space into one and during this merging, unlink overwrites the 
	pointer of deallocated space. so, we have to use unlink writing facility to overwrite GOT table address.
	
	first, we have to create a illusion of 2 free deallocated space one after another.
	
	let's take a look of unlink heap chunk structure
	
	Allocated Chunk
	
	    chunk -> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             | prev_size: size of the previous chunk, in bytes (used   |
             | by dlmalloc only if this previous chunk is free)        |
             +---------------------------------------------------------+
             | size: size of the chunk (the number of bytes between    |
             | "chunk" and "nextchunk") and 2 bits status information  |
      mem -> +---------------------------------------------------------+
             | fd: not used by dlmalloc because "chunk" is allocated   |
             | (user data therefore starts here)                       |
             + - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
             | bk: not used by dlmalloc because "chunk" is allocated   |
             | (there may be user data here)                           |
             + - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
             |                                                         .
             .                                                         .
             . user data (may be 0 bytes long)                         .
             .                                                         .
             .                                                         |
nextchunk -> + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
             | prev_size: not used by dlmalloc because "chunk" is      |
             | allocated (may hold user data, to decrease wastage)     |
             +---------------------------------------------------------+
			 
			 
			 
			 
	Deallocated Chunk

	
	 chunk -> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             | prev_size: may hold user data (indeed, since "chunk" is |
             | free, the previous chunk is necessarily allocated)      |
             +---------------------------------------------------------+
             | size: size of the chunk (the number of bytes between    |
             | "chunk" and "nextchunk") and 2 bits status information  |
      mem -> +---------------------------------------------------------+
             | fd: forward pointer to the next chunk in the circular   |
             | doubly-linked list (not to the next _physical_ chunk)   |
             +---------------------------------------------------------+
             | bk: back pointer to the previous chunk in the circular  |
             | doubly-linked list (not the previous _physical_ chunk)  |
             +---------------------------------------------------------+
             |                                                         .
             .                                                         .
             . unused space (may be 0 bytes long)                      .
             .                                                         .
             .                                                         |
nextchunk -> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             | prev_size: size of "chunk", in bytes (used by dlmalloc  |
             | because this previous chunk is free)                    |
             +---------------------------------------------------------+

			 
			 
			 Take a look at the following important parts of the Chunk_free() and the Unlink() macro before proceeding.

Important parts of the Chunk_free() function:

INTERNAL_SIZE_T hd = p->size;
 ...
 if (!hd & PREV_INUSE))     /* consolidate backward */    /* [A] */
 {
   prevsz = p->prev_size;
   p = chunk_at_offset(p, -(long)prevsz);                 /* [B] */
   sz += prevsz;
 
   if (p->fd == last_remainder(ar_ptr))
     islr = 1;
   else
     unlink(p, bck, fwd);
 }


 
 Unlink() macro:
	
#define unlink( P, BK, FD ) {            \
    BK = P->bk;                          \
    FD = P->fd;                          \
    FD->bk = BK;                         \
    BK->fd = FD; 
	
	
	
	
	
	https://conceptofproof.files.wordpress.com/2013/11/screen-shot-2013-11-19-at-2-16-25-am.png?w=1024&h=297
	
	